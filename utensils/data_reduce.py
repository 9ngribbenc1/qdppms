# This script contains functions and classes useful for doing data reduction
# of PPMS data, especially that generated by asymmetric delta measurements.


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import glob
from scipy.optimize import curve_fit
from scipy.stats import linregress

import utensils.re_values as ur


def reject_outliers(data, iq_range):
    # Higher iq_range will exclude fewer points.
    # iq_range = 0.5 will give 25, 50, 75%.
    
    pcnt = ( 1. - iq_range ) / 2.

    qlow, median, qhigh = data.quantile([pcnt, 0.5, 1-pcnt])
    iqr = qhigh - qlow 

    return data[(data - median).abs() <= 1.0*iqr].index


class OneDelta:


    def __init__(self, filename):

        self.data = pd.read_csv(filename, sep='\t+', engine='python')
        self.ordinal = ur.get_ordinal(filename)
        self.field = ur.get_field(filename)
        self.temp = ur.get_temp(filename)
        self.current = ur.get_current(filename, units='uA')

    def fit_lin(self, num_consider, num_fit, second_reject=True):

        #print(type(df['Voltage'][-num_fit:]))
        self.ind_norej = reject_outliers(self.data['Voltage'][-num_consider:],
                                         0.85)
        ind_end = np.arange(len(self.data['Voltage']))[num_fit:]
        #ind_end = np.arange(len(df['Voltage']))[-2*num_fit:-num_fit]
        ind_tofit = np.intersect1d(self.ind_norej, ind_end)
        #print(ind_tofit)
        self.result = linregress(self.data['Time'][ind_tofit],
                            self.data['Voltage'][ind_tofit]) 

        #plt.plot(df['Time'][-200:], df['Voltage'][-200:])
        #plt.plot(df['Time'][ind_good], df['Voltage'][ind_good]+12.e-6)


        if second_reject:
            self.data_linsub = (self.data['Voltage'][self.ind_norej] 
                        - self.data['Time'][self.ind_norej]*self.result[0])
            self.ind_norej2 = reject_outliers(self.data_linsub, 0.25)

            '''
            i=0
            if self.field == 1620:

                goodname = False
                while goodname == False:
                    name = ('voltage_trace_1620Oe_'+str(i)+'_'
                            +str(self.ordinal)+'.txt')
                    if os.path.isfile(name):
                        i += 1
                    else:
                        goodname = True

                self.data.to_csv(name, sep='\t', index=False)
                i += 1

                print('Wrote ', i, 'th data file.')

                '''
                #plt.plot(self.data['Time'][self.ind_norej],
                #         self.data['Voltage'][self.ind_norej])
                #plt.show()

            #plt.show()
            self.ind_tofit = np.intersect1d(self.ind_norej2, ind_end)
            self.result2 = linregress(self.data['Time'][self.ind_tofit],
                                      self.data['Voltage'][self.ind_tofit]) 
            
            self.val_lin = (self.result2[0]
                            *self.data['Time'].iloc[-int(num_fit/2)]
                            + self.result2[1])

        else:
            self.val_lin =  (self.result[0]
                            *self.data['Time'].iloc[-int(num_fit/2)]
                            + self.result[1])

class MeasLists:

    def __init__(self, lists):

        self.values = lists[0]
        self.fields = lists[1]
        self.field_inds = lists[2]
        self.ordinals = lists[3]
        
    def sort_by_field(self):

        sort_inds = np.asarray(self.fields).argsort()

        self.values = [self.values[i] for i in sort_inds]
        self.field_inds = [self.field_inds[i] for i in sort_inds]
        self.ordinals = [self.ordinals[i] for i in sort_inds]
        self.fields = [self.fields[i] for i in sort_inds]

class MeasDirectory:

    def __init__(self, globstrs):

        self.fln = glob.glob(globstrs[0])
        self.flp = glob.glob(globstrs[1])

    def organize_by_field(self, filelist, num_consider, num_fit):

        values = []
        fields = []
        field_inds = []
        ordinals = []

        for i in range(len(filelist)):
            mydat = OneDelta(filelist[i])
            mydat.fit_lin(num_consider, num_fit)
            field = mydat.field
            #values.append(mydat.val_lin)
            if field not in fields:
                fields.append(field)
                field_inds.append([i])
                ordinals.append([mydat.ordinal])
                values.append([mydat.val_lin])
            else:
                fldind = fields.index(field)
                field_inds[fldind].append(i)
                ordinals[fldind].append(mydat.ordinal)
                values[fldind].append(mydat.val_lin)

        return values, fields, field_inds, ordinals

    def read_data(self, num_consider, num_fit):

        self.lists_neg = MeasLists(self.organize_by_field(self.fln, 
                                                num_consider, num_fit))
        
        self.lists_pos = MeasLists(self.organize_by_field(self.flp, 
                                                num_consider, num_fit))
 
    def get_indices(self, i, lists):

        field = lists.fields[i]

        mn = max(lists.ordinals[i])+1
        firsts = [i
                  for i, x 
                  in enumerate(lists.ordinals[i]) 
                  if x < (mn-1)/2]

        seconds = [i
                  for i, x 
                  in enumerate(lists.ordinals[i]) 
                  if x > (mn-1)/2]

        final_fst = [lists.field_inds[i][j] for j in firsts]
        final_scd = [lists.field_inds[i][j] for j in seconds]

        #print(field, 'first', final_fst, 'second', final_scd)

        #return final_fst, final_scd
        return firsts, seconds

    def compute_voltages(self):

        num = len(self.lists_neg.fields)
        print('Length is ', num)
        self.values = pd.DataFrame({'Field': pd.Series(
                                                self.lists_neg.fields*2),
                                   'V pos': pd.Series(np.zeros(2*num)),
                                   'V neg': pd.Series(np.zeros(2*num)),
                                   'V diff': pd.Series(np.zeros(2*num)),
                                   'V sum': pd.Series(np.zeros(2*num))
                                   })

        self.lists_neg.sort_by_field()
        self.lists_pos.sort_by_field()
 
        for i in range(num):
            field = self.lists_neg.fields[i]
            
            is_n = self.get_indices(i, self.lists_neg)

            ind_pos = self.lists_pos.fields.index(field)
            is_p = self.get_indices(ind_pos, self.lists_pos)


            mean_neg_1 = np.asarray(self.lists_neg.values[i])[is_n[0]].mean()
            mean_neg_2 = np.asarray(self.lists_neg.values[i])[is_n[1]].mean()


            mean_pos_1 = np.asarray(self.lists_pos.values[i])[is_p[0]].mean()
            mean_pos_2 = np.asarray(self.lists_pos.values[i])[is_p[1]].mean()


            self.values.loc[i, 'Field'] = field
            self.values.loc[2*num-1-i, 'Field'] = field
            self.values.loc[i, 'V neg'] = mean_neg_1
            self.values.loc[i, 'V pos'] = mean_pos_1
            self.values.loc[2*num-1-i, 'V neg'] = mean_neg_2
            self.values.loc[2*num-1-i, 'V pos'] = mean_pos_2

            self.values.loc[i, 'V diff'] = mean_neg_1 - mean_pos_1
            self.values.loc[i, 'V sum'] = mean_neg_1 + mean_pos_1
            self.values.loc[2*num-1-i, 'V diff'] = mean_neg_2 - mean_pos_2
            self.values.loc[2*num-1-i, 'V sum'] = mean_neg_2 + mean_pos_2

        #self.values.sort_values('Field', axis=0, inplace=True)

    def write_data(self, filename):

        self.values.to_csv(filename, sep='\t', index=False)


class AsymDeltaMeas:

    def __init__(filename):
        pass

    def read_overview_file(self, filename):

        self.data = pd.read_csv(filename, skiprows=26, engine='python')

        self.data['even'] = (self.data['V+ 1'] + self.data['V- 1'])/2.
        self.data['odd'] = (self.data['V+ 1'] - self.data['V- 1'])/2.

    def shh_fit_highH(self, function, cutoff):

        self.params, pcov = curve_fit(function, 
                                 self.data['\g(m)\-(0)H'].loc[:cutoff], 
                                 self.data['even'].loc[:cutoff])

        print('params are ', self.params)

        self.data['fit'] = veven_v_H(self.data['\g(m)\-(0)H'], *self.params)

        plt.plot(self.data[r'\g(m)\-(0)H'], self.data['even'])
        plt.plot(self.data[r'\g(m)\-(0)H'], self.data['fit'])
        plt.show()


def veven_v_H(H, a, k, d):

    return a / (H-k) - d

def cubic_resistance(I, a, b, c, d):

    return a*I**3 + b*I**2 + c*I + d

def quintic_resistance(I, a, b, c, d, e, f):

    return a*I**5 + b*I**4 + c*I**3 + d*I**2 + e*I + f

def quadratic_sot(I, a):

    return a*I**2

class IVMeasST:

    def __init__(self):
        pass

    def readfiles(self, posid, negid):
        flistn = glob.glob(negid)
        fieldn = round(ur.get_field(flistn[0])/10.)*10.
        flistp = glob.glob(posid)
        fieldp = round(ur.get_field(flistp[0])/10.)*10.
        print('About to work on field ', fieldp, ' Oe')
        self.field = fieldp

        self.neg_files = []
        for f in flistn:
            self.neg_files.append(pd.read_csv(f, sep='\t', engine='python'))

        self.pos_files = []
        for f in flistp:
            self.pos_files.append(pd.read_csv(f, sep='\t', engine='python'))

        #print(self.neg_files[0].head())
        #print(self.neg_files[0].loc[:,'Voltage'])


    def find_quad(self, show):

        length = len(self.pos_files)
        #print(length, type(length))
        self.volts_pos = np.zeros(len(self.pos_files[0]))
        for df in self.pos_files:
            self.volts_pos += df.loc[:,'Voltage']/length

        length = len(self.neg_files)
        self.volts_neg = np.zeros(len(self.neg_files[0]))
        for df in self.neg_files:
            self.volts_neg += df.loc[:,'Voltage']/length

        #self.res, self.offset, r, p, s = linregress(
        #                    self.neg_files[0].loc[:,'Current'],
        #                    volts)

        self.params_pos, pcov = curve_fit(quintic_resistance, 
                                self.pos_files[0].loc[:,'Current'],
                                self.volts_pos)

        self.params_neg, pcov = curve_fit(quintic_resistance, 
                                self.neg_files[0].loc[:,'Current'],
                                self.volts_neg)

        self.volts_lin_pos = (self.volts_pos
                   - (self.pos_files[0].loc[:,'Current']**5)*self.params_pos[0] 
                   - (self.pos_files[0].loc[:,'Current']**3)*self.params_pos[2] 
                   - (self.pos_files[0].loc[:,'Current']**1)*self.params_pos[4] 
                   - self.params_pos[5])

        self.volts_lin_neg = (self.volts_neg 
                   - (self.neg_files[0].loc[:,'Current']**5)*self.params_neg[0] 
                   - (self.neg_files[0].loc[:,'Current']**3)*self.params_neg[2] 
                   - (self.neg_files[0].loc[:,'Current']**1)*self.params_neg[4] 
                   - self.params_neg[5])

        self.volts_lin_pos3 = (self.pos_files[3].loc[:,'Voltage'] 
                   - (self.pos_files[3].loc[:,'Current']**5)*self.params_pos[0] 
                   - (self.pos_files[3].loc[:,'Current']**3)*self.params_pos[2] 
                   - (self.pos_files[3].loc[:,'Current']**1)*self.params_pos[4] 
                   - self.params_pos[5])

        self.volts_quad = (self.volts_lin_pos - self.volts_lin_neg)/2.
        
        self.rep_current = self.pos_files[0].loc[:,'Current']

        self.params_quad, pcov = curve_fit(quadratic_sot, 
                                           self.rep_current,
                                           self.volts_quad)
        print('Curvature ', self.params_quad[0])
        self.volts_fit = quadratic_sot(self.rep_current, self.params_quad[0])

        if show:
            #plt.plot(self.pos_files[3].loc[:,'Current'], 
            #         self.volts_lin_pos3, 'b')
            #plt.plot(self.pos_files[3].loc[:,'Current'], 
            #         self.pos_files[3].loc[:,'Voltage'], 'k')
            plt.plot(self.pos_files[0].loc[:,'Current'],
                     self.volts_lin_pos, 'k')
            plt.plot(self.neg_files[0].loc[:,'Current'],
                     self.volts_lin_neg, 'g')
            plt.plot(self.neg_files[0].loc[:,'Current'],
                     self.volts_quad, 'b')

            plt.show()

class IVFieldSweep()

    def __init__(self):            
        self.measurements = []
        self.fields = []
        self.curvatures = []
        self.meas_num = 0

    def one_field(self, pos_id, neg_id):
        """Append a measurement at one field (both positive and negative)
        to the list of measurements, and compute its relevante parameters."""

        selfmeas_num += 1
        self.measurements.append(IVMeasST())
        self.measurements[-1].readfiles(pos_id, neg_id)
        self.measurements[-1].find_quad(show=False)
        self.fields.append(measurement[-1].field)
        self.curvatures.append(measurement[-1].params_quad[0])

    def make_big_plot(self)

        #fig, ((ax1, ax2, ax3),
        #      (ax4, ax5, ax6),
        #   (ax7, ax8, ax9)) = plt.subplots(3,3,  sharex = True, sharey = True)
        fig, axs = plt.subplots(3,3,  sharex = True, sharey = True)
        fig.suptitle('Even Current contribution')

        for i in range(self.meas_num):
            ix = i / self.meas_num
            iy = i % self.meas_num]
            axs[ix, iy].plot(x, self.measurements[i].volts_quad)
            axs[ix, iy].set_title(str(self.measurements[i].field/1000) ' kOe')
            
            if iy == 0:
                axs[ix, iy].set_ylabel('Voltage (V)')

            if ix == 2:
                axs[ix, iy].set_xlabel('Current (A)')
 
            '''
            ax1.plot(x, ys[0].volts_fit)
            ax1.set_title(str(self.measurements[i].field) ' kOe')
            ax1.set_ylabel('Voltage (V)')
            axs[0,1].plot(x, ys[1].volts_quad)
            ax2.plot(x, ys[1].volts_fit)
            ax2.set_title('3.5 kOe')
            ax3.plot(x, ys[2].volts_quad)
            ax3.plot(x, ys[2].volts_fit)
            ax3.set_title('4.0 kOe')
            ax4.plot(x, ys[3].volts_quad)
            ax4.plot(x, ys[3].volts_fit)
            ax4.set_title('4.5 kOe')
            ax4.set_ylabel('Voltage (V)')
            ax5.plot(x, ys[4].volts_quad)
            ax5.plot(x, ys[4].volts_fit)
            ax5.set_title('5.0 kOe')
            ax6.plot(x, ys[5].volts_quad)
            ax6.plot(x, ys[5].volts_fit)
            ax6.set_title('5.5 kOe')
            ax7.plot(x, ys[6].volts_quad)
            ax7.plot(x, ys[6].volts_fit)
            ax7.set_title('6.0 kOe')
            ax7.set_xlabel('Current (A)')
            ax7.set_ylabel('Voltage (V)')
            ax8.plot(x, ys[7].volts_quad)
            ax8.plot(x, ys[7].volts_fit)
            ax8.set_title('7.0 kOe')
            ax8.set_xlabel('Current (A)')
            ax9.plot(x, ys[8].volts_quad)
            ax9.plot(x, ys[8].volts_fit)
            ax9.set_title('8.0 kOe')
            ax9.set_xlabel('Current (A)')
            '''

            plt.show()


        
    
    





